name: XMBOX TS处理器name: XMBOX TS处理器name: XMBOX TS处理器



on:

  repository_dispatch:

    types: [process_ts]on:on:



env:  repository_dispatch:  repository_dispatch:

  TASK_DIR: tasks

  OUTPUT_DIR: output    types: [process_ts]    types: [process_ts]



jobs:

  process-ts:

    runs-on: ubuntu-latestenv:env:

    permissions:

      contents: write  TASK_DIR: tasks  TASK_DIR: tasks

      

    steps:  OUTPUT_DIR: output  OUTPUT_DIR: output

    - name: 检出代码

      uses: actions/checkout@v4

      with:

        ref: masterjobs:jobs:

        token: ${{ secrets.GITHUB_TOKEN }}

      process-ts:  process-ts:

    - name: 设置 FFmpeg

      uses: FedericoCarboni/setup-ffmpeg@v3    runs-on: ubuntu-latest    runs-on: ubuntu-latest

      id: setup-ffmpeg

      with:    permissions:    permissions:

        ffmpeg-version: release

        architecture: x64      contents: write      contents: write

    

    - name: 验证 FFmpeg 安装            

      run: |

        echo "🔧 验证FFmpeg安装..."    steps:    steps:

        ffmpeg -version | head -5

        echo ""    - name: 检出代码    - name: 检出代码

        echo "📋 支持的格式:"

        ffmpeg -formats | grep -E "(mpegts|mp4)" | head -10      uses: actions/checkout@v4      uses: actions/checkout@v4

        echo ""

        echo "✅ FFmpeg准备就绪"      with:      with:

    

    - name: 准备工作目录        ref: master        ref: master

      run: |

        TASK_ID="${{ github.event.client_payload.task_id }}"        token: ${{ secrets.GITHUB_TOKEN }}        token: ${{ secrets.GITHUB_TOKEN }}

        mkdir -p "$TASK_DIR/$TASK_ID"

        mkdir -p "$OUTPUT_DIR"        

        echo "TASK_ID=$TASK_ID" >> $GITHUB_ENV

        - name: 设置 FFmpeg    - name: 设置 FFmpeg

    - name: 处理TS文件

      run: |      uses: FedericoCarboni/setup-ffmpeg@v3      uses: FedericoCarboni/setup-ffmpeg@v3

        cd "$TASK_DIR/$TASK_ID"

              with:      with:

        # 验证TS文件

        echo "🔍 验证TS文件..."        ffmpeg-version: release        ffmpeg-version: release

        total_files=$(ls -1 *.ts 2>/dev/null | wc -l)

        if [ "$total_files" -eq 0 ]; then        architecture: x64        architecture: x64

          echo "❌ 错误：没有找到TS文件"

          exit 1        

        fi

        echo "✅ 发现 $total_files 个TS文件"    - name: 验证 FFmpeg 安装    - name: 验证 FFmpeg 安装

        

        # 准备输出目录      run: |      run: |

        FINAL_OUTPUT="../../$OUTPUT_DIR/${TASK_ID}.mp4"

        TEMP_TS="../../$OUTPUT_DIR/${TASK_ID}_temp.ts"        echo "🔧 验证FFmpeg安装..."        echo "🔧 验证FFmpeg安装..."

        mkdir -p "$(dirname "$FINAL_OUTPUT")"

                ffmpeg -version | head -5        ffmpeg -version | head -5

        # 简单二进制合并

        echo "🔄 使用二进制合并..."        echo ""        echo ""

        if ! cat $(ls -1v *.ts) > "$TEMP_TS"; then

          echo "❌ 错误：合并失败"        echo "📋 支持的格式:"        echo "📋 支持的格式:"

          rm -f "$TEMP_TS"

          exit 1        ffmpeg -formats | grep -E "(mpegts|mp4)" | head -10        ffmpeg -formats | grep -E "(mpegts|mp4)" | head -10

        fi

                echo ""        echo ""

        # 转换为MP4

        echo "🎬 转换为MP4..."        echo "✅ FFmpeg准备就绪"        echo "✅ FFmpeg准备就绪"

        if ! ffmpeg -v error -fflags +igndts -i "$TEMP_TS" -c copy -movflags +faststart "$FINAL_OUTPUT"; then

          echo "❌ 错误：转换失败"        

          rm -f "$TEMP_TS" "$FINAL_OUTPUT"

          exit 1    - name: 准备工作目录    - name: 准备工作目录

        fi

              run: |      run: |

        # 清理临时文件

        rm -f "$TEMP_TS"        TASK_ID="${{ github.event.client_payload.task_id }}"        TASK_ID="${{ github.event.client_payload.task_id }}"

        

        # 验证输出        mkdir -p "$TASK_DIR/$TASK_ID"        mkdir -p "$TASK_DIR/$TASK_ID"

        if [ ! -f "$FINAL_OUTPUT" ]; then

          echo "❌ 错误：输出文件不存在"        mkdir -p "$OUTPUT_DIR"        mkdir -p "$OUTPUT_DIR"

          exit 1

        fi        echo "TASK_ID=$TASK_ID" >> $GITHUB_ENV        echo "TASK_ID=$TASK_ID" >> $GITHUB_ENV

        

        # 检查文件大小        

        output_size=$(stat -f %z "$FINAL_OUTPUT" 2>/dev/null || stat -c %s "$FINAL_OUTPUT")

        echo "📊 输出文件大小: $output_size 字节"    - name: 处理TS文件    - name: 处理TS文件

        

        if [ "$output_size" -lt 1024 ]; then      run: |      run: |

          echo "❌ 错误：输出文件太小"

          rm -f "$FINAL_OUTPUT"        cd "$TASK_DIR/$TASK_ID"        cd "$TASK_DIR/$TASK_ID"

          exit 1

        fi                

        

        echo "✅ 处理完成：$(basename "$FINAL_OUTPUT")"        # 验证TS文件        # 验证TS文件

    

    - name: 创建发布        echo "🔍 验证TS文件..."        echo "🔍 验证TS文件..."

      if: success()

      uses: softprops/action-gh-release@v1        total_files=$(ls -1 *.ts 2>/dev/null | wc -l)        total_files=$(ls -1 *.ts 2>/dev/null | wc -l)

      with:

        tag_name: task-${{ env.TASK_ID }}        if [ "$total_files" -eq 0 ]; then        if [ "$total_files" -eq 0 ]; then

        name: "视频：${{ github.event.client_payload.title }}"

        files: ${{ env.OUTPUT_DIR }}/${{ env.TASK_ID }}.mp4          echo "❌ 错误：没有找到TS文件"          echo "❌ 错误：没有找到TS文件"

        token: ${{ secrets.GITHUB_TOKEN }}
          exit 1          exit 1

        fi        fi

        echo "✅ 发现 $total_files 个TS文件"        echo "✅ 发现 $total_files 个TS文件"

                

        # 准备输出目录和临时目录        # 准备输出目录

        FINAL_OUTPUT="../../$OUTPUT_DIR/${TASK_ID}.mp4"        FINAL_OUTPUT="../../$OUTPUT_DIR/${TASK_ID}.mp4"

        TEMP_TS="../../$OUTPUT_DIR/${TASK_ID}_temp.ts"        mkdir -p "$(dirname "$FINAL_OUTPUT")"

        mkdir -p "$(dirname "$FINAL_OUTPUT")"        

                # 验证每个TS文件并输出调试信息

        # 检查每个文件的基本完整性        echo "� 验证单个文件..."

        echo "🔍 检查文件完整性..."        for f in $(ls -1v *.ts); do

        for f in *.ts; do          echo "检查文件: $f"

          if [ ! -s "$f" ]; then          ffprobe -v warning "$f" 2>&1 || {

            echo "❌ 错误：文件 $f 是空文件"            echo "❌ 错误：文件 $f 验证失败"

            exit 1            exit 1

          fi          }

        done        done

                

        # 尝试方法1: 简单二进制合并        echo "📝 生成文件列表..."

        echo "🔄 尝试方法1: 二进制合并..."        rm -f files.txt

        if cat $(ls -1v *.ts) > "$TEMP_TS" 2>/dev/null; then        for f in $(ls -1v *.ts); do

          if ffmpeg -v error -i "$TEMP_TS" -c copy -y "$FINAL_OUTPUT" 2>/dev/null; then          echo "file '$(pwd)/$f'" >> files.txt

            echo "✅ 方法1成功"        done

            rm -f "$TEMP_TS"        

            exit 0        echo "📄 文件列表内容:"

          fi        cat files.txt

          rm -f "$TEMP_TS" "$FINAL_OUTPUT"        

        fi        # 使用FFmpeg合并（启用详细日志）

                echo "🎬 开始合并..."

        # 方法2: 使用concat demuxer        if ! ffmpeg -v warning -f concat -safe 0 -i files.txt -c copy "$FINAL_OUTPUT" 2>&1; then

        echo "🔄 尝试方法2: concat demuxer..."          echo "❌ 错误：合并失败"

        echo > files.txt          rm -f "$FINAL_OUTPUT"

        for f in $(ls -1v *.ts); do          exit 1

          echo "file '$f'" >> files.txt        fi

        done        

                # 验证输出文件

        if ffmpeg -v error -f concat -safe 0 -i files.txt -c copy -y "$FINAL_OUTPUT" 2>/dev/null; then        echo "🔍 验证输出文件..."

          echo "✅ 方法2成功"        if ! ffprobe -v warning "$FINAL_OUTPUT" 2>&1; then

          rm -f files.txt          echo "❌ 错误：输出文件验证失败"

          exit 0          rm -f "$FINAL_OUTPUT"

        fi          exit 1

        rm -f files.txt "$FINAL_OUTPUT"        fi

                

        # 方法3: 使用concat protocol        # 检查文件大小

        echo "🔄 尝试方法3: concat protocol..."        output_size=$(stat -f %z "$FINAL_OUTPUT" || stat -c %s "$FINAL_OUTPUT")

        input_files=""        echo "📊 输出文件大小: $output_size 字节"

        for f in $(ls -1v *.ts); do        

          [ -n "$input_files" ] && input_files="$input_files|"        if [ "$output_size" -lt 1024 ]; then

          input_files="${input_files}${f}"          echo "❌ 错误：输出文件太小，可能未正确合并"

        done          rm -f "$FINAL_OUTPUT"

                  exit 1

        if ffmpeg -v error -i "concat:$input_files" -c copy -y "$FINAL_OUTPUT" 2>/dev/null; then        fi

          echo "✅ 方法3成功"        

          exit 0        echo "✅ 处理完成：$(basename "$FINAL_OUTPUT")"

        fi    

        rm -f "$FINAL_OUTPUT"    - name: 创建发布

              uses: softprops/action-gh-release@v1

        # 方法4: 使用segment muxer      with:

        echo "🔄 尝试方法4: segment muxer..."        tag_name: task-${{ env.TASK_ID }}

        if ffmpeg -v error -i "$(ls -1v *.ts | head -1)" -f segment -segment_list files.txt -c copy segments%03d.ts && \        name: "TS处理结果 - ${{ github.event.client_payload.title }}"

           ffmpeg -v error -f concat -safe 0 -i files.txt -c copy -y "$FINAL_OUTPUT" 2>/dev/null; then        body: |

          echo "✅ 方法4成功"          🎥 处理任务ID: ${{ env.TASK_ID }}

          rm -f segments*.ts files.txt          📝 视频标题: ${{ github.event.client_payload.title }}

          exit 0          📊 处理文件数: ${{ github.event.client_payload.file_count }}

        fi          ⏱ 处理时间: ${{ github.event.created_at }}

        rm -f segments*.ts files.txt "$FINAL_OUTPUT"        files: |

                  ${{ env.OUTPUT_DIR }}/${{ env.TASK_ID }}.mp4

        # 所有方法都失败      env:

        echo "❌ 错误：所有合并方法都失败了"        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        exit 1
    
    - name: 创建发布
      if: success()
      uses: softprops/action-gh-release@v1
      with:
        tag_name: task-${{ env.TASK_ID }}
        name: "视频：${{ github.event.client_payload.title }}"
        files: ${{ env.OUTPUT_DIR }}/${{ env.TASK_ID }}.mp4
        token: ${{ secrets.GITHUB_TOKEN }}